<p><span style="color: #33cccc;"><strong>Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.</strong></span></p><p><span style="color: #33cccc;"><strong>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in Figure 1: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in Figure 1.</strong></span></p><p style="text-align: center;"><img class="alignnone size-full wp-image-2286" src="http://www.liuchuo.net/wp-content/uploads/2016/08/Snip20160820_53.png" alt="Snip20160820_53" width="1108" height="688" srcset="https://cdn1.liuchuo.net/wp-content/uploads/2016/08/Snip20160820_53.png 1108w, https://cdn1.liuchuo.net/wp-content/uploads/2016/08/Snip20160820_53-300x186.png 300w, https://cdn1.liuchuo.net/wp-content/uploads/2016/08/Snip20160820_53-768x477.png 768w, https://cdn1.liuchuo.net/wp-content/uploads/2016/08/Snip20160820_53-1024x636.png 1024w" sizes="(max-width: 1108px) 100vw, 1108px"><br><span style="color: #33cccc;"><strong>Figure 1</strong></span></p><p style="text-align: left;"><span style="color: #3366ff;"><strong>Input Specification:<br></strong></span><span style="color: #33cccc;"><strong>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt;= 100, the number of nodes in a tree, M (&lt; N), the number of non-leaf nodes, and 0 &lt; S &lt; 230, the given weight number. The next line contains N positive numbers where Wi (&lt;1000) corresponds to the tree node Ti. Then M lines follow, each in the format:</strong></span></p><p><span style="color: #33cccc;"><strong>ID K ID[1] ID[2] … ID[K]</strong></span><br><span style="color: #33cccc;"><strong>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</strong></span></p><p><span style="color: #33cccc;"><strong>Note: sequence {A1, A2, …, An} is said to be greater than sequence {B1, B2, …, Bm} if there exists 1 &lt;= k &lt; min{n, m} such that Ai = Bi for i=1, … k, and Ak+1 &gt; Bk+1.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>20 9 24</strong></span><br><span style="color: #33cccc;"><strong>10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2</strong></span><br><span style="color: #33cccc;"><strong>00 4 01 02 03 04</strong></span><br><span style="color: #33cccc;"><strong>02 1 05</strong></span><br><span style="color: #33cccc;"><strong>04 2 06 07</strong></span><br><span style="color: #33cccc;"><strong>03 3 11 12 13</strong></span><br><span style="color: #33cccc;"><strong>06 1 09</strong></span><br><span style="color: #33cccc;"><strong>07 2 08 10</strong></span><br><span style="color: #33cccc;"><strong>16 1 15</strong></span><br><span style="color: #33cccc;"><strong>13 3 14 16 17</strong></span><br><span style="color: #33cccc;"><strong>17 2 18 19</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>10 5 2 7</strong></span><br><span style="color: #33cccc;"><strong>10 4 10</strong></span><br><span style="color: #33cccc;"><strong>10 3 3 6 2</strong></span><br><span style="color: #33cccc;"><strong>10 3 3 6 2</strong></span><br><span style="color: #99cc00;"><strong>题目大意：给出树的结构和权值，找从根结点到叶子结点的路径上的权值相加之和等于给定目标数的路径，并且从大到小输出路径</strong></span><br><span style="color: #ff9900;"><strong>分析：对于接收孩子结点的数据时，每次完全接收完就对孩子结点按照权值进行排序（序号变，根据权值变），这样保证深度优先遍历的时候直接输出就能输出从大到小的顺序。记录路径采取这样的方式：首先建立一个path数组，传入一个nodeNum记录对当前路径来说这是第几个结点（这样直接在path[nodeNum]里面存储当前结点的孩子结点的序号，这样可以保证在先判断return的时候，path是从0~numNum-1的值确实是要求的路径结点）。然后每次要遍历下一个孩子结点的之前，令path[nodeNum] = 孩子结点的序号，这样就保证了在return的时候当前path里面从0~nodeNum-1的值就是要输出的路径的结点序号，输出这个序号的权值即可，直接在return语句里面输出。</strong></span><br><span style="color: #ff9900;"><strong>注意：当sum==target的时候，记得判断是否孩子结点是空，要不然如果不空说明没有到底部，就直接return而不是输出路径。。。（这对接下来的孩子结点都是正数才有用，负权无用）。</strong></span></p><p> </p>