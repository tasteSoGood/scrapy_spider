<p>Given an unsorted array of integers, find the length of longest increasing subsequence.<br>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.<br>Your algorithm should run in O(n2) complexity.</p><p>Follow up: Could you improve it to O(n log n) time complexity?</p><p><span style="color: #ff9900;"><strong>update v2.0: //更高效的O(nlogn)方法～</strong></span><br><span style="color: #ff9900;"><strong> 维护一个数组vector&lt;int&gt; v～</strong></span><br><span style="color: #ff9900;"><strong> 将nums[0]加入数组，对于每一个来的数nums[i]，如果大于v.back()，就将它push入数组～</strong></span><br><span style="color: #ff9900;"><strong> 否则，就找到第一个比这个数大的位置，将该位置的数字替换为nums[i]～～</strong></span><br><span style="color: #ff9900;"><strong> 最终返回v数组的长度~~~就是最长字串的长度啦～</strong></span></p><p></p>