<p><strong><span style="color: #339966;">问题描述</span></strong><br><span style="color: #33cccc;">回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。</span><br><span style="color: #33cccc;"> 交换的定义是：交换两个相邻的字符</span><br><span style="color: #33cccc;"> 例如mamad</span><br><span style="color: #33cccc;"> 第一次交换 ad : mamda</span><br><span style="color: #33cccc;"> 第二次交换 md : madma</span><br><span style="color: #33cccc;"> 第三次交换 ma : madam (回文！完美！)</span><br><strong><span style="color: #339966;">输入格式</span></strong><br><span style="color: #33cccc;">第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)</span><br><span style="color: #33cccc;"> 第二行是一个字符串，长度为N.只包含小写字母</span><br><strong><span style="color: #339966;">输出格式</span></strong><br><span style="color: #33cccc;">如果可能，输出最少的交换次数。</span><br><span style="color: #33cccc;"> 否则输出Impossible</span><br><strong><span style="color: #339966;">样例输入</span></strong><br><span style="color: #33cccc;">5</span><br><span style="color: #33cccc;"> mamad</span><br><strong><span style="color: #339966;">样例输出</span></strong><br><span style="color: #33cccc;">3</span><br><strong><span style="color: #ff9900;">分析：过程见代码注释部分。其中有两个注意点：</span></strong><br><strong><span style="color: #ff9900;">1.impossible的情况：如果有一个字符出现的次数是奇数次数，而且n是偶数，那么不可能构成回文</span></strong><br><strong><span style="color: #ff9900;">如果n是奇数，但是已经有一个字符出现的次数是奇数次数了，那么如果又有一个字符是奇数次数，就不可能构成回文。</span></strong><br><strong><span style="color: #ff9900;">2.如果n是奇数，计算中间那个字符交换的次数的时候，不需要模拟把这个数移动到中间去，因为移动到中间的话假设有一对数都在左边或者都在右边，</span></strong><br><strong><span style="color: #ff9900;">那么交换成回文的时候就要经过中间，就会每次把cnt多加了1，而这个1是没有必要的，因为可以所有的回文移动完了之后再把这个独立的奇数移动过去，才能保证交换次数最少。<br></span></strong></p><p> </p>