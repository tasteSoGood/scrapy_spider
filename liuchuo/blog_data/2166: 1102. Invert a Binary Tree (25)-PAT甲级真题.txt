<p><span style="color: #33cccc;"><strong>The following is from Max Howell @twitter:</strong></span><br><span style="color: #33cccc;"><strong>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</strong></span><br><span style="color: #33cccc;"><strong>Now it’s your turn to prove that YOU CAN invert a binary tree!</strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=10) which is the total number of nodes in the tree — and hence the nodes are numbered from 0 to N-1. Then N lines follow, each corresponds to a node from 0 to N-1, and gives the indices of the left and right children of the node. If the child does not exist, a “-” will be put at the position. Any pair of children are separated by a space.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>8</strong></span><br><span style="color: #33cccc;"><strong>1 –</strong></span><br><span style="color: #33cccc;"><strong>– –</strong></span><br><span style="color: #33cccc;"><strong>0 –</strong></span><br><span style="color: #33cccc;"><strong>2 7</strong></span><br><span style="color: #33cccc;"><strong>– –</strong></span><br><span style="color: #33cccc;"><strong>– –</strong></span><br><span style="color: #33cccc;"><strong>5 –</strong></span><br><span style="color: #33cccc;"><strong>4 6</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>3 7 2 6 4 0 5 1</strong></span><br><span style="color: #33cccc;"><strong>6 5 7 4 3 2 0 1</strong></span><br><span style="color: #99cc00;"><strong>题目大意：反转一棵二叉树，给出原二叉树的每个结点的左右孩子，输出它的层序和前序遍历～</strong></span></p><p><span style="color: #ff9900;"><strong>分析：1. 反转二叉树就是存储的时候所有左右结点都交换。</strong></span><br><span style="color: #ff9900;"><strong>2. 二叉树使用{id, l, r, index, level}存储每个结点的id, 左右结点,下标值，和当前层数～</strong></span><br><span style="color: #ff9900;"><strong>3. 根结点是所有左右结点中没有出现的那个结点～</strong></span><br><span style="color: #ff9900;"><strong>4. 已知根结点，用递归的方法可以把中序遍历的结果push_back到数组v1里面,直接输出就是中序，排序输出就是层序（排序方式，层数小的排前面，相同层数时，index大的排前面）</strong></span></p><p> </p>