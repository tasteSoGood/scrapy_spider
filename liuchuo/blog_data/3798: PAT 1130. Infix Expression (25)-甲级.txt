<p><strong><span style="color: #33cccc;">Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of the operators.</span></strong></p><p><span style="color: #3366ff;"><strong>Input Specification:<br></strong></span><strong><span style="color: #33cccc;">Each input file contains one test case. For each case, the first line gives a positive integer N ( &lt;= 20 ) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i-th line corresponds to the i-th node) in the format:<br></span></strong><strong><span style="color: #33cccc;">data left_child right_child<br></span></strong><strong><span style="color: #33cccc;">where data is a string of no more than 10 characters, left_child and right_child are the indices of this node’s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by -1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</span></strong></p><p><img class="wp-image-5721 aligncenter" src="https://cdn1.liuchuo.net/wp-content/uploads/2016/08/1130.png" alt="" width="420" height="156"><br><span style="color: #3366ff;"><strong>Output Specification:<br></strong></span><strong><span style="color: #33cccc;">For each case, print in a line the infix expression, with parentheses reflecting the precedences of the operators. Note that there must be no extra parentheses for the final expression, as is shown by the samples. There must be no space between any symbols.<br></span></strong><span style="color: #3366ff;"><strong>Sample Input 1:</strong></span><br><strong><span style="color: #33cccc;">8</span></strong><br><strong><span style="color: #33cccc;">* 8 7</span></strong><br><strong><span style="color: #33cccc;">a -1 -1</span></strong><br><strong><span style="color: #33cccc;">* 4 1</span></strong><br><strong><span style="color: #33cccc;">+ 2 5</span></strong><br><strong><span style="color: #33cccc;">b -1 -1</span></strong><br><strong><span style="color: #33cccc;">d -1 -1</span></strong><br><strong><span style="color: #33cccc;">– -1 6</span></strong><br><strong><span style="color: #33cccc;">c -1 -1</span></strong><br><span style="color: #3366ff;"><strong>Sample Output 1:</strong></span><br><strong><span style="color: #33cccc;">(a+b)*(c*(-d))</span></strong><br><span style="color: #3366ff;"><strong>Sample Input 2:</strong></span><br><strong><span style="color: #33cccc;">8</span></strong><br><strong><span style="color: #33cccc;">2.35 -1 -1</span></strong><br><strong><span style="color: #33cccc;">* 6 1</span></strong><br><strong><span style="color: #33cccc;">– -1 4</span></strong><br><strong><span style="color: #33cccc;">% 7 8</span></strong><br><strong><span style="color: #33cccc;">+ 2 3</span></strong><br><strong><span style="color: #33cccc;">a -1 -1</span></strong><br><strong><span style="color: #33cccc;">str -1 -1</span></strong><br><strong><span style="color: #33cccc;">871 -1 -1</span></strong><br><span style="color: #3366ff;"><strong>Sample Output 2:</strong></span><br><strong><span style="color: #33cccc;">(a*2.35)+(-(str%871))</span></strong></p><p><span style="color: #99cc00;"><strong>题目大意：给一个二叉树，输出中缀表达式，且加上括号表示运算的优先级～</strong></span><br><span style="color: #ff9900;"><strong>分析：首先根据所有孩子结点编号寻找1～n中没有出现过的编号标记为root，即树的根结点～然后进行从root结点开始dfs～</strong></span><span style="color: #ff9900;"><strong>dfs递归拼接 “(” + 左子树 + 根 + 右子树 + “)”<br>递归有四种情况（有效的只有三种）：<br>1. 左右子树都空 返回 “(” + 根 + “)”<br>2. 左空右不空 返回 “(” + 根 + 右子树 + “)”<br>3. 左不空右空 这种情况不存在<br>4. 左右都不空 返回 “(” + 左子树 + 根 + 右子树 + “)”<br>最后递归返回的ans，最外层可能会被括号包起来，也可能不被包起来。要判断一下，如果被包起来，把最外层括号去掉即可～</strong></span></p><p></p>