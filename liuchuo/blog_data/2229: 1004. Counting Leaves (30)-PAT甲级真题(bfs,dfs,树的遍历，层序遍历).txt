<p><span style="color: #33cccc;"><strong>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</strong></span></p><p><span style="color: #3366ff;"><strong>Input</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format:</strong></span></p><p><span style="color: #33cccc;"><strong>ID K ID[1] ID[2] … ID[K]</strong></span><br><span style="color: #33cccc;"><strong>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.</strong></span></p><p><span style="color: #3366ff;"><strong>Output</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.</strong></span></p><p><span style="color: #33cccc;"><strong>The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input</strong></span></p><p><span style="color: #33cccc;"><strong>2 1</strong></span><br><span style="color: #33cccc;"><strong>01 1 02</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Output</strong></span></p><p><span style="color: #33cccc;"><strong>0 1</strong></span></p><p><span style="color: #99cc00;"><strong>题目大意：给出一棵树，问每一层各有多少个叶子结点。</strong></span></p><p><span style="color: #ff9900;"><strong>分析：可以用dfs也可以用bfs。</strong></span><span style="color: #ff9900;"><strong>dfs的话，用二维数组保存每一个有孩子结点的结点以及他们的孩子结点，从根结点开始遍历，直到遇到叶子结点，就将当前层数depth的book[depth]++; 标记第depth层拥有的叶子结点数，最后输出～</strong></span><span style="color: #ff9900;"><strong>如果用bfs，设立两个数组，第一个level，保存i结点的层数，为了bfs的时候可以让当前结点的层数是它的父结点层数+1，第二个数组book，保存i层所拥有的叶子结点的个数。变量maxlevel保存最大的层数～</strong></span></p><p></p>