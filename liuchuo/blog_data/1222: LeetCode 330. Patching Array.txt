<p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p><p>Example 1:<br>nums = [1, 3], n = 6<br>Return 1.</p><p>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p><p>Example 2:<br>nums = [1, 5, 10], n = 20<br>Return 2.<br>The two patches can be [2, 4].</p><p>Example 3:<br>nums = [1, 2, 2], n = 5<br>Return 0.</p><p><strong><span style="color: #99cc00;">题目大意：</span></strong><br><strong><span style="color: #99cc00;"> 给一个有序非负整数列nums和一个整数n，最少需要添加多少个数可以使得[1,n]间的每一个数都可以被数列中若干个数的和来表示。输出最小需要添加多少个数字。</span></strong></p><p><strong><span style="color: #ff9900;">分析：</span></strong><br><strong><span style="color: #ff9900;"> 假设[0,t)是暂时能够满足题意的区间，当t&lt;=n的时候，对于每下一个nums[i]：</span></strong><br><strong><span style="color: #ff9900;"> 0.如果nums[i]比t小，那么[0,t)区间内的每一个数加上nums[i]后，区间就被扩展为[0,t+nums[i])了。</span></strong><br><strong><span style="color: #ff9900;"> 1.如果nums[i]比t大，那么必须要加入一个数才能满足扩展区间后的连续性。能加入的这个数当然是越大越好，但是不能超过t，因为超过t的话就会有t之后这个数之前的区间不满足。所以可以令t=t+t，这是它能扩展的最大区间了。此时用cnt计数，cnt+1表示加入了一个数（这个数是t）。</span></strong><br><strong><span style="color: #ff9900;"> 注意点：一开始全都用的int结果在测试用例Last executed input:[1,2,31,33] 2147483647 这个用例下面超时了</span></strong><br><strong><span style="color: #ff9900;"> 后来机智的想了一下发现是如果t当前的值很大又执行了t = t + t会溢出导致t变成了一个很小的值，然后再while肯定超时啦。</span></strong><br><strong><span style="color: #ff9900;"> 所以把int t = 1改为long long int类型就AC啦。啦啦啦。</span></strong></p><p> </p>