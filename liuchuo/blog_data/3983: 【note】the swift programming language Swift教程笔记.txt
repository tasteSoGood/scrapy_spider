<p>// ——————–Swift教程——————————————-<br>要么变量初始化让其可以推断出类型，要么直接指定一个类型，不可以写：<br>var a<br>这样的语句，会让系统不明白a到底是什么类型的变量</p><p> </p><p>允许嵌套多行注释</p><p> </p><p>可以访问不同整数类型的min和max属性来获取对应类型的最小值和最大值<br>let minValue = UInt8.min<br>let maxValue = UInt8.max</p><p> </p><p>可以添加额外的0或者下划线来增加数值的可读性，并不影响字面量：<br>let paddedDouble = 000123.456<br>let oneMillion = 1_000_000</p><p> </p><p>如果赋值的数值超过了变量或者常量可存储的范围，编译的时候会报错</p><p> </p><p>加号两边的数的类型必须相同，如果不进行类型的转换，无法直接相加<br>将Double或Float转化为Int的时候，会截断到整数部分，舍弃小数部分</p><p> </p><p>如果在需要使用Bool类型的地方使用了非布尔值，Swift的类型安全机制会报错<br>这样能够避免错误并保证这块代码的意图总是清晰的。<br>if i {</p><p>}<br>//这样的语句不被允许，会报错</p><p> </p><p>元组：把多个值组合成一个复合值，元组内的值可以是任意类型，并不要求是相同类型，常用作函数的多个返回值组成一个元组返回<br>let http404Error = (404, “Not Found”)或者：<br>let http404Error = (statusCode: 404, description: “OK”)</p><p>两种提取元组中元素的方法：<br>1.<br>let (statusCode, statusMessage) = http404Error<br>print(“the status codes is \\(statusCode), the status message is \\(statusMessage)”)<br>注意，可以只需要其中一部分的值，不需要的值可用_代替，如：<br>let (statusCode, _) = http404Error</p><p>2.print(“the status code is \\(http404Error.0), the statue message is \\(http404Error.1)”)</p><p> </p><p>//可选类型<br>Swift的nil和Objective-C的nil的区别：在Objective-C中，nil是一个指向不存在对象的指针。而在Swift中，nil不是指针，它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为nil，不只是对象类型。</p><p>强制解析：当你确定可选类型确实包含值后，可以再可选名字后面加!来获取值，这个!表示我知道这个可选有值，请使用它。<br>if convertedNumber != nil {<br>print(“it is \\(convertedNumber!).”)<br>} else {<br>print(“～～”)<br>}</p><p>也可以这样写，使用可选绑定来判断可选类型是否包含值，如果包含就把值赋给一个临时变量或者变量。<br>if let actualNumber = Int(possibleNumber) {<br>print(“actualNumber is \\(actualNumber)”)<br>}<br>这样转换成功的话actualNumber就能在if下面语句中用，这时候就可以不用写actualNumber的!啦～</p><p>//隐式解析可选类型<br>当可选类型第一次赋值后就可以确定之后一定有值的时候，隐式解析可选类型可以定义时把后面的问号改成感叹号，来声明一个隐式解析可选类型，后面使用它时候就不需要强制拆封了<br>let possibleString: String! = “djskfjls”<br>let aString: String = possiableString</p><p> </p><p>// 错误处理<br>1. 通过枚举类型表示错误<br>enum VendingMachineError: Error {<br>case invalidSelection<br>case insufficientFunds(coinsNeeded: Int)<br>case outOfStock<br>}</p><p>2. 抛出一个错误表明有意外情况发生 使用throw关键字<br>throw VendingMachineError.insufficientFunds(coinsNeed: 5)</p><p>3.某个错误被抛出时，附近的某部分代码必须负责处理这个错误<br>swift有4种错误处理方式：<br>– 把函数抛出的错误传递给调用此函数的代码<br>– 用do-catch语句处理错误<br>– 将错误作为可选类型处理<br>– 断言此错误根本不会发生</p><p>为了表示一个函数、方法或者构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有throws关键字的函数叫做throwing函数。<br>func canThrowErrors() throws -&gt; String</p><p>一个throwing函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域<br>只有throwing函数可以传递错误。任何在某个非throwing函数内部抛出的错误只能在函数内部处理</p><p> </p><p>-+ 把函数抛出的错误传递给调用此函数的代码<br>struct Item {<br>var price: Int<br>var count: Int<br>}<br>class VendingMachine {<br>var inventory = [<br>“Candy Bar”: Item(price: 12, count: 7),<br>“Chips”: Item(price: 10, count: 4),<br>“Pretzels”: Item(price: 7, count: 11)<br>]<br>var coinsDeposited = 0<br>func dispenseSnack(snack: String) {<br>print(“Dispensing \\(snack)”)<br>}<br>func vend(itemNamed name: String) throws {<br>guard let item = inventory[name] else {<br>throw VendingMachineError.InvalidSelection<br>}<br>guard item.count &gt; 0 else {<br>throw VendingMachineError.OutOfStock<br>}<br>guard item.price &lt;= coinsDeposited else {<br>throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price – coinsDeposited)<br>}<br>coinsDeposited -= item.price<br>var newItem = item<br>newItem.count -= 1<br>inventory[name] = newItem<br>print(“Dispensing \\(name)”)<br>}<br>}</p><p>在vend(itemNamed:)方法的实现中使用了guard语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于 throw语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p><p>throwing 构造器能像 throwing 函数一样传递错误.例如下面代码中的 PurchasedSnack 构造器在构造过程中调用 了throwing函数,并且通过传递到它的调用者来处理这些错误。<br>struct PurchasedSnack {<br>let name: String<br>init(name: String, vendingMachine: VendingMachine) throws {<br>try vendingMachine.vend(itemNamed: name)<br>self.name = name<br>}<br>}</p><p> </p><p>-+ 用do-catch处理错误<br>var vendingMachine = VendingMachine()<br>vendingMachine.coinsDeposited = 8<br>do {<br>try buyFavoriteSnack(“Alice”, vendingMachine: vendingMachine)<br>} catch VendingMachineError.InvalidSelection {<br>print(“Invalid Selection.”)<br>} catch VendingMachineError.OutOfStock {<br>print(“Out of Stock.”)<br>} catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>print(“Insufficient funds. Please insert an additional \\(coinsNeeded) coins.”)<br>}<br>// 打印 “Insufficient funds. Please insert an additional 2 coins.”</p><p>buyFavoriteSnack(person:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到 catch 子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。</p><p> </p><p>-+ 将错误转换成可选值<br>可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil 。例如,在下面的代码中,x和y有着相同的数值和等价的含义:<br>func someThrowingFunction() throws -&gt; Int {<br>// …<br>}<br>let x = try? someThrowingFunction()<br>let y: Int?<br>do {<br>y = try someThrowingFunction()<br>} catch {<br>y = nil<br>}<br>如果 someThrowingFunction() 抛出一个错误， x 和 y 的值是 nil 。否则 x 和 y 的值就是该函数的返回值。注 意，无论 someThrowingFunction() 的返回值类型是什么类型， x 和 y 都是这个类型的可选类型。例子中此函数返 回一个整型，所以 x 和 y 是可选整型。</p><p> </p><p>-+ 禁用错误传递（保证这个错误不会发生）<br>有时你知道某个 throwing 函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写 tr<br>y! 来禁用错误传递，这会把调用包装在一个不会有错误抛出的运行时断言中。如果真的抛出了错误，你会得到一 个运行时错误。<br>例如：<br>let photo = try! loadImage(atPath: “./Resources/John Appleseed.jpg”)</p><p> </p><p>// 指定清理操作<br>使用defer语句在即将离开当前代码块时候执行一系列语句，该语句让你能执行一些必要的清理操作，不管是 以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如 return 或者 break 的语句。例如，你可以用 defer 语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。<br>延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条 defer 语句中的代码会在第二条 defer 语句中的代码被执行之后才执行，以此类推。<br>func processFile(filename: String) throws {<br>if exists(filename) {<br>let file = open(filename)<br>defer {<br>close(file)<br>}<br>while let line = try file.readline() {<br>// 处理文件。<br>}<br>// close(file) 会在这里被调用，即作用域的最后。<br>}<br>}</p><p>注意：即使没有涉及到错误处理，你也可以使用 defer 语句。</p><p> </p><p>//类型转换<br>-+ 检查类型：用类型检查操作符( is )来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回<br>true ，否则返回 false 。<br>for item in library {<br>if item is Movie {<br>movieCount += 1<br>} else if item is Song {<br>songCount += 1<br>}<br>}</p><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类<br>型，用类型转换操作符(as? 或 as!)。<br>条件形式as? 返回一个你试图向下转成的类型的<br>可选值。强制形式 as! 把试图向下转型和强制解包转换结果结合为一个操作。<br>当你不确定向下转型可以成功时，用类型转换的条件形式( as? )。条件形式的类型转换总是返回一个可选<br>值，并且若下转是不可能的，可选值将是 nil 。这使你能够检查向下转型是否成功。 只有你可以确定向下转型一定会成功时，才使用强制形式( as! )。当你试图向下转型为一个不正确的类型<br>时，强制形式的类型转换会触发一个运行时错误。</p><p>在这个示例中，数组中的每一个 item 可能是 Movie 或 Song 。事前你不知道每个 item 的真实类型，所以 这里使用条件形式的类型转换( as? )去检查循环里的每次下转:<br>for item in library {<br>if let movie = item as? Movie {<br>print(“Movie: ‘\\(movie.name)’, dir. \\(movie.director)”)<br>} else if let song = item as? Song {<br>print(“Song: ‘\\(song.name)’, by \\(song.artist)”)<br>}<br>}<br>注意：转换没有真的改变实例或它的值。根本的实例保持不变;只是简单地把它作为它被转换成的类型来使用。</p><p>Swift 为不确定类型提供了两种特殊的类型别名:<br>• Any 可以表示任何类型，包括函数类型。<br>• AnyObject 可以表示任何类类型的实例。</p><p>var things = [Any]()<br>things.append(0)<br>things.append(0.0)<br>things.append(42)<br>things.append(3.14159)<br>things.append(“hello”)<br>things.append((3.0, 5.0))<br>things.append(Movie(name: “Ghostbusters”, director: “Ivan Reitman”))<br>things.append({ (name: String) -&gt; String in “Hello, \\(name)” })</p><p>注意:<br>Any 类型可以表示所有类型的值，包括可选类型。Swift 会在你用 Any 类型来表示一个可选值的时候，给你一<br>个警告。如果你确实想使用 Any 类型来承载可选值，你可以使用 as 操作符显示转换为 Any ，如下所示:<br>let optionalNumber: Int? = 3 things.append(optionalNumber) // 警告<br>things.append(optionalNumber as Any) // 没有警告</p><p> </p><p>//扩展<br>扩展就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。<br>这包括在没有权限获取原始源代码的情 况下扩展类型的能力<br>扩展和 Objective-C 中的分类类似。(与 Objective-C 不同的是，Swift的扩展没有名字。)<br>使用关键字 extension 来声明扩展：<br>extension SomeType {<br>// 为 SomeType 添加的新功能写到这里<br>}<br>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。</p><p> </p><p>//协议<br>协议的定义方式与类、结构体和枚举的定义非常相似:<br>protocol SomeProtocol {<br>// 这里是协议的定义部分<br>}<br>遵循 多个协议时，各协议之间用逗号( , )分隔:<br>struct SomeStructure: FirstProtocol, AnotherProtocol {<br>// 这里是结构体的定义部分<br>}</p><p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔:<br>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {<br>// 这里是类的定义部分<br>}</p><p> </p><p>// 泛型<br>泛型代码让你能够根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的<br>重复，用一种清晰和抽象的方式来表达代码的意图。<br>泛型函数可以适用于任何类型，下面的 swapTwoValues(_:_:) 函数是上面三个函数的泛型版本:<br>func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {<br>let temporaryA = a<br>a = b<br>b = temporaryA<br>}</p><p>var someInt = 3<br>var anotherInt = 107 swapTwoValues(&amp;someInt, &amp;anotherInt)<br>// someInt 现在 107, and anotherInt 现在 3<br>var someString = “hello”<br>var anotherString = “world”<br>swapTwoValues(&amp;someString, &amp;anotherString)<br>// someString 现在 “world”, and anotherString 现在 “hello”</p><p> </p><p>//访问控制<br>Swift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源 文件所属的模块相关。<br>• open和public: 开放访问和公开访问可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件 里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为开放或者公开访问。<br>• internal: 内部访问可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况 下，某个接口只在应用程序或框架内部使用时，你可以将其设置为内部访问。<br>• fileprivate: 文件私有访问限制实体只能被所定义的文件内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。<br>• private: 私有访问限制实体只能在所定义的作用域内使用。需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。<br>通过修饰符 open，public，internal，filepart，private 来声明实体的访问级别:<br>public class SomePublicClass {}<br>internal class SomeInternalClass {}<br>fileprivate class SomeFilePrivateClass {}<br>private class SomePrivateClass {}<br>public var somePublicVariable = 0<br>internal let someInternalConstant = 0<br>fileprivate func someFilePrivateFunction() {}<br>private func somePrivateFunction() {}</p><p> </p><p>//溢出运算符<br>在默认情况下，当向一个整数赋予超过它容量的值时，Swift 默认会报错，而不是生成一个无效的数。这个行为 为我们在运算过大或着过小的数的时候提供了额外的安全性。<br>然而，也可以选择让系统在数值溢出的时候采取截断处理，而非报错。可以使用 Swift 提供的三个溢出运算符来<br>让系统支持整数溢出运算。这些运算符都是以 &amp; 开头的:<br>• 溢出加法 &amp;+<br>• 溢出减法 &amp;-<br>• 溢出乘法 &amp;*</p><p> </p>