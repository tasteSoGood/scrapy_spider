<p><span style="color: #3366ff;"><strong>525. Contiguous Array</strong></span><br><span style="color: #33cccc;"><strong>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</strong></span></p><p><span style="color: #33cccc;"><strong>Example 1:</strong></span><br><span style="color: #33cccc;"><strong>Input: [0,1]</strong></span><br><span style="color: #33cccc;"><strong>Output: 2</strong></span><br><span style="color: #33cccc;"><strong>Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</strong></span><br><span style="color: #33cccc;"><strong>Example 2:</strong></span><br><span style="color: #33cccc;"><strong>Input: [0,1,0]</strong></span><br><span style="color: #33cccc;"><strong>Output: 2</strong></span><br><span style="color: #33cccc;"><strong>Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</strong></span><br><span style="color: #33cccc;"><strong>Note: The length of the given binary array will not exceed 50,000.</strong></span></p><p><span style="color: #99cc00;"><strong>题目大意：给一个二进制数组，找最长的连续子数组，要求子数组里面的0和1的个数相等～</strong></span><br><span style="color: #ff9900;"><strong>分析：0和1数组，可以考虑把0换成-1，变成-1和0数组，那么本质上就是找是否有下标从i～j的总和为0的子数组～</strong></span><br><span style="color: #ff9900;"><strong>令map保存sum和sum对应的下标的值，遍历数组每次计算数组当前的sum，如果当前sum之前已经出现过，比如说之前有过一个sum = 2，现在又sum = 2了，说明在第一次sum等于2的时候，它前面所有元素加起来总和是2，那么在它前面去掉2个元素1就能满足0，同理当前的sum = 2也可以通过去掉最前面的2个元素1使sum = 0，所以看看i – m[sum]是否比之前的最大值大，如果比之前最大值大就更新最大值～</strong></span></p><p> </p>