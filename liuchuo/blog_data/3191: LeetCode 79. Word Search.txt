<p><span style="color: #3366ff;"><strong>79. Word Search</strong></span><br><span style="color: #33cccc;"><strong>Given a 2D board and a word, find if the word exists in the grid.</strong></span></p><p><span style="color: #33cccc;"><strong>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</strong></span></p><p><span style="color: #33cccc;"><strong>For example,</strong></span><br><span style="color: #33cccc;"><strong>Given board =</strong></span></p><p><span style="color: #33cccc;"><strong>[</strong></span><br><span style="color: #33cccc;"><strong> [‘A’,’B’,’C’,’E’],</strong></span><br><span style="color: #33cccc;"><strong> [‘S’,’F’,’C’,’S’],</strong></span><br><span style="color: #33cccc;"><strong> [‘A’,’D’,’E’,’E’]</strong></span><br><span style="color: #33cccc;"><strong>]</strong></span><br><span style="color: #33cccc;"><strong>word = “ABCCED”, -&gt; returns true,</strong></span><br><span style="color: #33cccc;"><strong>word = “SEE”, -&gt; returns true,</strong></span><br><span style="color: #33cccc;"><strong>word = “ABCB”, -&gt; returns false.</strong></span></p><p><span style="color: #99cc00;"><strong>题目大意：给一个char型二维数组和一个word字符串，寻找网格中是否含有word字符串，只能通过相邻（垂直或者水平）的格子连接～</strong></span><br><span style="color: #ff9900;"><strong>分析：对于二维数组中的每一个点都开始遍历，如果当前点的字母正好等于word[0]就进入dfs，设立flag标记是否找到，设立visit标记是否访问：</strong></span><br><span style="color: #ff9900;"><strong>首先令起始节点visit[j][k]标记为已经访问过，接着dfs，如果flag为true直接return，如果当前index正好为word的最后一个字符下标就标记flag为true，return。</strong></span><br><span style="color: #ff9900;"><strong>从四个方向开始对结点进行深度优先搜索，首先要保证搜索的结点满足：1.是合法的在网格之内的 2.未被访问过 3.当前字符与要找的word[index+1]相同。满足则标记visit[tx][ty] = true,且dfs tx和ty以及index+1，两个dfs后要把他重新置为false～</strong></span><br><span style="color: #ff9900;"><strong>这样最后返回flag的值即为是否能找到的结果～</strong></span></p><p> </p>