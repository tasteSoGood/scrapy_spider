<p><span style="color: #33cccc;"><strong>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</strong></span></p><p><span style="color: #33cccc;"><strong>The left subtree of a node contains only nodes with keys less than the node’s key.</strong></span><br><span style="color: #33cccc;"><strong>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</strong></span><br><span style="color: #33cccc;"><strong>Both the left and right subtrees must also be binary search trees.</strong></span><br><span style="color: #33cccc;"><strong>If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST.</strong></span></p><p><span style="color: #33cccc;"><strong>Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.</strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, first print in a line “YES” if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or “NO” if not. Then if the answer is “YES”, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input 1:</strong></span><br><span style="color: #33cccc;"><strong>7</strong></span><br><span style="color: #33cccc;"><strong>8 6 5 7 10 8 11</strong></span><br><span style="color: #3366ff;"><strong>Sample Output 1:</strong></span><br><span style="color: #33cccc;"><strong>YES</strong></span><br><span style="color: #33cccc;"><strong>5 7 6 8 11 10 8</strong></span><br><span style="color: #3366ff;"><strong>Sample Input 2:</strong></span><br><span style="color: #33cccc;"><strong>7</strong></span><br><span style="color: #33cccc;"><strong>8 10 11 8 6 7 5</strong></span><br><span style="color: #3366ff;"><strong>Sample Output 2:</strong></span><br><span style="color: #33cccc;"><strong>YES</strong></span><br><span style="color: #33cccc;"><strong>11 8 10 7 5 6 8</strong></span><br><span style="color: #3366ff;"><strong>Sample Input 3:</strong></span><br><span style="color: #33cccc;"><strong>7</strong></span><br><span style="color: #33cccc;"><strong>8 6 8 5 10 9 11</strong></span><br><span style="color: #3366ff;"><strong>Sample Output 3:</strong></span><br><span style="color: #33cccc;"><strong>NO</strong></span><br><span style="color: #99cc00;"><strong>题目大意：给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。</strong></span><br><span style="color: #ff9900;"><strong>分析：假设它是二叉搜索树，一开始isMirror为FALSE，根据二叉搜索树的性质将已知的前序转换为后序，转换过程中，如果发现最后输出的后序数组长度不为n，那就设isMirror为true，然后清空后序数组，重新再转换一次（根据镜面二叉搜索树的性质），如果依旧转换后数组大小不等于n，就输出no否则输出yes</strong></span></p><p> </p>