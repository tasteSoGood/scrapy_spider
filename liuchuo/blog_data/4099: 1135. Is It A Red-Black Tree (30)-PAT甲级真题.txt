<p><span style="color: #33cccc;"><strong>There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties:</strong></span></p><p><span style="color: #33cccc;"><strong>(1) Every node is either red or black.</strong></span><br><span style="color: #33cccc;"><strong>(2) The root is black.</strong></span><br><span style="color: #33cccc;"><strong>(3) Every leaf (NULL) is black.</strong></span><br><span style="color: #33cccc;"><strong>(4) If a node is red, then both its children are black.</strong></span><br><span style="color: #33cccc;"><strong>(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</strong></span></p><p><span style="color: #33cccc;"><strong>For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.</strong></span></p><p><span style="color: #33cccc;"><strong>For each given binary search tree, you are supposed to tell if it is a legal red-black tree.</strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains several test cases. The first line gives a positive integer K (&lt;=30) which is the total number of cases. For each case, the first line gives a positive integer N (&lt;=30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.</strong></span><img class="alignnone size-full wp-image-5723" src="https://cdn1.liuchuo.net/wp-content/uploads/2016/08/1135.png" alt="" width="1360" height="492"></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>3</strong></span><br><span style="color: #33cccc;"><strong>9</strong></span><br><span style="color: #33cccc;"><strong>7 -2 1 5 -4 -11 8 14 -15</strong></span><br><span style="color: #33cccc;"><strong>9</strong></span><br><span style="color: #33cccc;"><strong>11 -2 1 -7 5 -4 8 14 -15</strong></span><br><span style="color: #33cccc;"><strong>8</strong></span><br><span style="color: #33cccc;"><strong>10 -7 5 -6 8 15 -11 17</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>Yes</strong></span><br><span style="color: #33cccc;"><strong>No</strong></span><br><span style="color: #33cccc;"><strong>No</strong></span></p><p><strong><span style="color: #99cc00;">题目大意：给一棵二叉搜索树的前序遍历，判断它是否为红黑树，是输出Yes，否则输出No。</span></strong></p><p><span style="color: #ff9900;"><strong>分析：判断以下几点：</strong></span><br><span style="color: #ff9900;"><strong>1.根结点是否为黑色 </strong></span><br><span style="color: #ff9900;"><strong>2.如果一个结点是红色，它的孩子节点是否都为黑色 </strong></span><br><span style="color: #ff9900;"><strong>3.从任意结点到叶子结点的路径中，黑色结点的个数是否相同</strong></span><br><span style="color: #ff9900;"><strong>所以分为以下几步：</strong></span><br><span style="color: #ff9900;"><strong>0. 根据先序建立一棵树，用链表表示</strong></span><br><span style="color: #ff9900;"><strong>1. 判断根结点（题目所给先序的第一个点即根结点）是否是黑色【arr[0] &lt; 0】</strong></span><br><span style="color: #ff9900;"><strong>2. 根据建立的树，从根结点开始遍历，如果当前结点是红色，判断它的孩子节点是否为黑色，递归返回结果【judge1函数】</strong></span><br><span style="color: #ff9900;"><strong>3. 从根节点开始，递归遍历，检查每个结点的左子树的高度和右子树的高度（这里的高度指黑色结点的个数），比较左右孩子高度是否相等，递归返回结果【judge2函数】</strong></span></p><p><span style="color: #33cccc;"><strong>注意：终于知道自己PAT考试的时候错在哪了。。。维基百科定义：红黑树（英语：Red–black tree）是一种自平衡二叉查找树。AVL树：在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。所以说红黑树不是一种AVL树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。而我根据先序遍历直接建树后判断了是否AVL平衡，把判断是否平衡的那段代码注释掉就AC了～</strong></span></p><p></p>