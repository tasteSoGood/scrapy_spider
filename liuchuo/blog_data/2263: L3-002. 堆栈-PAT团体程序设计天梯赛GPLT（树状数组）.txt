<p><span style="color: #33cccc;"><strong>大家都知道“堆栈”是一种“先进后出”的线性结构，基本操作有“入栈”（将新元素插入栈顶）和“出栈”（将栈顶元素的值返回并从堆栈中将其删除）。现请你实现一种特殊的堆栈，它多了一种操作叫“查中值”，即返回堆栈中所有元素的中值。对于N个元素，若N是偶数，则中值定义为第N/2个最小元；若N是奇数，则中值定义为第(N+1)/2个最小元。</strong></span></p><p><span style="color: #3366ff;"><strong>输入格式：</strong></span></p><p><span style="color: #33cccc;"><strong>输入第一行给出正整数N（&lt;= 105）。随后N行，每行给出一个操作指令，为下列3种指令之一：</strong></span></p><p><span style="color: #33cccc;"><strong>Push key</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>PeekMedian</strong></span><br><span style="color: #33cccc;"><strong>其中Push表示入栈，key是不超过105的正整数；Pop表示出栈；PeekMedian表示查中值。</strong></span></p><p><span style="color: #3366ff;"><strong>输出格式：</strong></span></p><p><span style="color: #33cccc;"><strong>对每个入栈指令，将key入栈，并不输出任何信息。对每个出栈或查中值的指令，在一行中打印相应的返回结果。若指令非法，就打印“Invalid”。</strong></span></p><p><span style="color: #3366ff;"><strong>输入样例：</strong></span><br><span style="color: #33cccc;"><strong>17</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>PeekMedian</strong></span><br><span style="color: #33cccc;"><strong>Push 3</strong></span><br><span style="color: #33cccc;"><strong>PeekMedian</strong></span><br><span style="color: #33cccc;"><strong>Push 2</strong></span><br><span style="color: #33cccc;"><strong>PeekMedian</strong></span><br><span style="color: #33cccc;"><strong>Push 1</strong></span><br><span style="color: #33cccc;"><strong>PeekMedian</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Push 5</strong></span><br><span style="color: #33cccc;"><strong>Push 4</strong></span><br><span style="color: #33cccc;"><strong>PeekMedian</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #3366ff;"><strong>输出样例：</strong></span><br><span style="color: #33cccc;"><strong>Invalid</strong></span><br><span style="color: #33cccc;"><strong>Invalid</strong></span><br><span style="color: #33cccc;"><strong>3</strong></span><br><span style="color: #33cccc;"><strong>2</strong></span><br><span style="color: #33cccc;"><strong>2</strong></span><br><span style="color: #33cccc;"><strong>1</strong></span><br><span style="color: #33cccc;"><strong>2</strong></span><br><span style="color: #33cccc;"><strong>4</strong></span><br><span style="color: #33cccc;"><strong>4</strong></span><br><span style="color: #33cccc;"><strong>5</strong></span><br><span style="color: #33cccc;"><strong>3</strong></span><br><span style="color: #33cccc;"><strong>Invalid</strong></span></p><p><span style="color: #ff9900;"><strong>分析：如果排序查找的话会超时，用树状数组，即求第k = (s.size() + 1) / 2大的数。查询小于等于x的数的个数是否等于k的时候用二分法更快～</strong></span></p><p> </p>