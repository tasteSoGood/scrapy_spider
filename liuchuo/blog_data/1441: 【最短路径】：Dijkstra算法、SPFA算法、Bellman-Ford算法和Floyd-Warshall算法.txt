<p class="p1"><strong><span style="color: #3366ff;">求最短路径最常用的算法有：</span></strong><br><strong><span style="color: #ff9900;">Dijkstra<span class="s2">算法、</span>SPFA<span class="s2">算法、</span>Bellman-Ford<span class="s2">算法和</span>Floyd-Warshall</span></strong><span class="s2"><strong><span style="color: #ff9900;">算法。</span></strong><br></span>Dijkstra<span class="s2">算法、</span>SPFA<span class="s2">算法、</span>Bellman-Ford<span class="s2">算法这</span>三个求<strong><span style="color: #ff9900;">单源最短路径</span></strong>，最后一个Floyd-Warshall<span class="s2">算法</span>可以求<strong><span style="color: #ff9900;">全局最短路径</span></strong>也可以求单源路径，效率比较低。<br>SPFA算法是Bellman算法的<strong><span style="color: #99cc00;">队列优化</span></strong>。<br>Dijkstra<span class="s2">算法</span>不能求带负权边的最短路径，而SPFA算法、Bellman-Ford算法、Floyd-Warshall可以求带负权边的最短路径。<br>Bellman-Ford算法的核心代码只有4行，Floyd-Warshall算法的核心代码只有5行。</p><p>1.最基本的求单源最短路径方法是<strong><span style="color: #33cccc;">图的深度优先遍历</span></strong>：<br>用 min = 99999999 记录路径的最小值，book[i]标记结点 i 是否被访问过~</p><p>2.单源最短路径：Dijkstra算法<br>dis[i]是需要不断更新的数组，它表示当前结点1(源点)到其余各结点的最短路径长度~<br>book[i]标记当前结点最短路径是确定值还是估计值~<br>算法实现的过程是：每次找到离结点1最近的那个点，然后以该结点为中心扩展，最终得到源点到所有点的最短路径~~每次新扩展一个距离最短的点，更新与其相邻的点的距离。当所有边权都为正时，由于不会存在一个距离更短的没扩展过的点，所以这个点的距离永远不会再被改变，因而保证了算法的正确性。不过根据这个原理，<span style="color: #ff99cc;"><strong>用Dijkstra求最短路的图不能有负权边</strong></span>，因为扩展到负权边的时候会产生更短的距离，有可能就破坏了已经更新的点距离不会改变的性质~~<br>找到所有估计值当中最小的值min以及它的结点u，然后把该结点u标记为确定值，通过这个确定值为中转点更新别的所有值的最短路径(松弛别的两个顶点连接的边)</p><p></p><p>3.Bellman-Ford算法——解决负权边<br>算法思想：对所有的边进行n-1次“松弛”操作</p><p></p><p>4.Bellman-Ford的队列优化(SPFA算法)<br>每次选取首顶点u，对u的所有出边进行松弛操作~如果有一条u-&gt;v的边，通过这条边使得源点到顶点v的路程变短，且顶点v不在当前队列中，就把这个顶点v放入队尾。同一个顶点在队列中出现多次是毫无意义的，所以用一个数组来判重复，判断哪些点已经在队列中。对顶点u的所有出边都松弛完毕后，就将顶点v出队~</p><p> </p>