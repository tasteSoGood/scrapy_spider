<p><span style="color: #33cccc;"><strong>本题要求你实现一个天梯赛专属在线地图，队员输入自己学校所在地和赛场地点后，该地图应该推荐两条路线：一条是最快到达路线；一条是最短距离的路线。题目保证对任意的查询请求，地图上都至少存在一条可达路线。</strong></span></p><p><span style="color: #3366ff;"><strong>输入格式：</strong></span></p><p><span style="color: #33cccc;"><strong>输入在第一行给出两个正整数N（2 &lt;= N &lt;=500）和M，分别为地图中所有标记地点的个数和连接地点的道路条数。随后M行，每行按如下格式给出一条道路的信息：</strong></span></p><p><span style="color: #33cccc;"><strong>V1 V2 one-way length time</strong></span></p><p><span style="color: #33cccc;"><strong>其中V1和V2是道路的两个端点的编号（从0到N-1）；如果该道路是从V1到V2的单行线，则one-way为1，否则为0；length是道路的长度；time是通过该路所需要的时间。最后给出一对起点和终点的编号。</strong></span></p><p><span style="color: #3366ff;"><strong>输出格式：</strong></span></p><p><span style="color: #33cccc;"><strong>首先按下列格式输出最快到达的时间T和用节点编号表示的路线：</strong></span></p><p><span style="color: #33cccc;"><strong>Time = T: 起点 =&gt; 节点1 =&gt; … =&gt; 终点</strong></span></p><p><span style="color: #33cccc;"><strong>然后在下一行按下列格式输出最短距离D和用节点编号表示的路线：</strong></span></p><p><span style="color: #33cccc;"><strong>Distance = D: 起点 =&gt; 节点1 =&gt; … =&gt; 终点</strong></span></p><p><span style="color: #33cccc;"><strong>如果最快到达路线不唯一，则输出几条最快路线中最短的那条，题目保证这条路线是唯一的。而如果最短距离的路线不唯一，则输出途径节点数最少的那条，题目保证这条路线是唯一的。</strong></span></p><p><span style="color: #33cccc;"><strong>如果这两条路线是完全一样的，则按下列格式输出：</strong></span></p><p><span style="color: #33cccc;"><strong>Time = T; Distance = D: 起点 =&gt; 节点1 =&gt; … =&gt; 终点</strong></span></p><p><span style="color: #3366ff;"><strong>输入样例1：</strong></span><br><span style="color: #33cccc;"><strong>10 15</strong></span><br><span style="color: #33cccc;"><strong>0 1 0 1 1</strong></span><br><span style="color: #33cccc;"><strong>8 0 0 1 1</strong></span><br><span style="color: #33cccc;"><strong>4 8 1 1 1</strong></span><br><span style="color: #33cccc;"><strong>5 4 0 2 3</strong></span><br><span style="color: #33cccc;"><strong>5 9 1 1 4</strong></span><br><span style="color: #33cccc;"><strong>0 6 0 1 1</strong></span><br><span style="color: #33cccc;"><strong>7 3 1 1 2</strong></span><br><span style="color: #33cccc;"><strong>8 3 1 1 2</strong></span><br><span style="color: #33cccc;"><strong>2 5 0 2 2</strong></span><br><span style="color: #33cccc;"><strong>2 1 1 1 1</strong></span><br><span style="color: #33cccc;"><strong>1 5 0 1 3</strong></span><br><span style="color: #33cccc;"><strong>1 4 0 1 1</strong></span><br><span style="color: #33cccc;"><strong>9 7 1 1 3</strong></span><br><span style="color: #33cccc;"><strong>3 1 0 2 5</strong></span><br><span style="color: #33cccc;"><strong>6 3 1 2 1</strong></span><br><span style="color: #33cccc;"><strong>5 3</strong></span><br><span style="color: #3366ff;"><strong>输出样例1：</strong></span><br><span style="color: #33cccc;"><strong>Time = 6: 5 =&gt; 4 =&gt; 8 =&gt; 3</strong></span><br><span style="color: #33cccc;"><strong>Distance = 3: 5 =&gt; 1 =&gt; 3</strong></span><br><span style="color: #3366ff;"><strong>输入样例2:</strong></span><br><span style="color: #33cccc;"><strong>7 9</strong></span><br><span style="color: #33cccc;"><strong>0 4 1 1 1</strong></span><br><span style="color: #33cccc;"><strong>1 6 1 3 1</strong></span><br><span style="color: #33cccc;"><strong>2 6 1 1 1</strong></span><br><span style="color: #33cccc;"><strong>2 5 1 2 2</strong></span><br><span style="color: #33cccc;"><strong>3 0 0 1 1</strong></span><br><span style="color: #33cccc;"><strong>3 1 1 3 1</strong></span><br><span style="color: #33cccc;"><strong>3 2 1 2 1</strong></span><br><span style="color: #33cccc;"><strong>4 5 0 2 2</strong></span><br><span style="color: #33cccc;"><strong>6 5 1 2 1</strong></span><br><span style="color: #33cccc;"><strong>3 5</strong></span><br><span style="color: #3366ff;"><strong>输出样例2:</strong></span><br><span style="color: #33cccc;"><strong>Time = 3; Distance = 4: 3 =&gt; 2 =&gt; 5</strong></span><br><span style="color: #ff9900;"><strong>分析：用两个Dijkstra + DFS。一个求最快路径（如果相同求路径的那条），一个求最短路径（如果相同求结点数最小的那条）～～求最快路径可以直接在Dijkstra里面求前驱结点Timepre数组~~~求最短路径因为要求结点数最小的那条，所以要用dispre的二维数组存储所有结点的最短路径，然后用DFS求出满足条件的结点数最小的那条～～</strong></span></p><p><span style="color: #99cc00;"><strong>注意：</strong></span><br><span style="color: #99cc00;"><strong>1.一开始最后一个测试用例“答案错误”，后来发现是自己在求最短路径（第二个答案distance）的时候忘记了temppath每一次深搜结束后的pop_back();</strong></span><br><span style="color: #99cc00;"><strong>2.如果直接使用DFS的话，会导致最后一个测试用例“运行超时”～</strong></span></p><p></p>