<p><span style="color: #33cccc;"><strong>Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given “Is PAT&amp;TAP symmetric?”, the longest symmetric sub-string is “s PAT&amp;TAP s”, hence you must output 11.</strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case which gives a non-empty string of length no more than 1000.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, simply print the maximum length in a line.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>Is PAT&amp;TAP symmetric?</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>11</strong></span></p><p><strong><span style="color: #ff9900;">分析：dp[i][j]表示s[i]到s[j]所表示的字串是否是回文字串。只有0和1，递推方程为： </span></strong></p><p><span style="color: #ff9900;"><strong>1 当s[i] == s[j] : dp[i][j] = dp[i+1][j-1]</strong></span></p><p><span style="color: #ff9900;"><strong>2 当s[i] != s[j] : dp[i][j] =0</strong></span></p><p><span style="color: #ff9900;"><span style="color: #ff9900;"><strong>3 边界：dp[i][i] = 1, dp[i][i+1] = (s[i] == s[i+1]) ? 1 : 0</strong></span></span><strong style="color: #ff9900;">因为i、j如果从小到大的顺序来枚举的话，无法保证更新dp[i][j]的时候dp[i+1][j-1]已经被计算过。因此不妨考虑按照字串的长度和子串的初试位置进行枚举，即第一遍将长度为3的子串的dp的值全部求出，第二遍通过第一遍结果计算出长度为4的子串的dp的值…这样就可以避免状态无法转移的问题</strong></p><p><span style="color: #ff9900;"><strong>首先初始化dp[i][i] = 1, dp[i][i+1]，把长度为1和2的都初始化好，然后从L = 3开始一直到 L &lt;= len 根据动态规划的递归方程来判断</strong></span></p><p></p>