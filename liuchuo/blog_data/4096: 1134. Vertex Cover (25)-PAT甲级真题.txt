<p><span style="color: #33cccc;"><strong>A vertex cover of a graph is a set of vertices such that each edge of the graph is incident to at least one vertex of the set. Now given a graph with several vertex sets, you are supposed to tell if each of them is a vertex cover or not.</strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than 104), being the total numbers of vertices and the edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N-1) of the two ends of the edge.</strong></span></p><p><span style="color: #33cccc;"><strong>After the graph, a positive integer K (&lt;= 100) is given, which is the number of queries. Then K lines of queries follow, each in the format:</strong></span></p><p><span style="color: #33cccc;"><strong>Nv v[1] v[2] … v[Nv]</strong></span></p><p><span style="color: #33cccc;"><strong>where Nv is the number of vertices in the set, and v[i]’s are the indices of the vertices.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each query, print in a line “Yes” if the set is a vertex cover, or “No” if not.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>10 11</strong></span><br><span style="color: #33cccc;"><strong>8 7</strong></span><br><span style="color: #33cccc;"><strong>6 8</strong></span><br><span style="color: #33cccc;"><strong>4 5</strong></span><br><span style="color: #33cccc;"><strong>8 4</strong></span><br><span style="color: #33cccc;"><strong>8 1</strong></span><br><span style="color: #33cccc;"><strong>1 2</strong></span><br><span style="color: #33cccc;"><strong>1 4</strong></span><br><span style="color: #33cccc;"><strong>9 8</strong></span><br><span style="color: #33cccc;"><strong>9 1</strong></span><br><span style="color: #33cccc;"><strong>1 0</strong></span><br><span style="color: #33cccc;"><strong>2 4</strong></span><br><span style="color: #33cccc;"><strong>5</strong></span><br><span style="color: #33cccc;"><strong>4 0 3 8 4</strong></span><br><span style="color: #33cccc;"><strong>6 6 1 7 5 4 9</strong></span><br><span style="color: #33cccc;"><strong>3 1 8 4</strong></span><br><span style="color: #33cccc;"><strong>2 2 8</strong></span><br><span style="color: #33cccc;"><strong>7 9 8 7 6 5 4 2</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>No</strong></span><br><span style="color: #33cccc;"><strong>Yes</strong></span><br><span style="color: #33cccc;"><strong>Yes</strong></span><br><span style="color: #33cccc;"><strong>No</strong></span><br><span style="color: #33cccc;"><strong>No</strong></span></p><p><span style="color: #99cc00;"><strong>题目大意：给n个结点m条边，再给k个集合。对这k个集合逐个进行判断。每个集合S里面的数字都是结点编号，求问整个图所有的m条边两端的结点，是否至少一个结点出自集合S中。如果是，输出Yes否则输出No</strong></span></p><p><span style="color: #ff9900;"><strong>分析：用vector v[n]保存某结点属于的某条边的编号，比如a b两个结点构成的这条边的编号为0，则v[a].push_back(0)，v[b].push_back(0)——表示a属于0号边，b也属于0号边。对于每一个集合做判断，遍历集合中的每一个元素，将当前元素能够属于的边的编号i对应的hash[i]标记为1，表示这条边是满足有一个结点出自集合S中的。最后判断hash数组中的每一个值是否都是1，如果有不是1的，说明这条边的两端结点没有一个出自集合S中，则输出No。否则输出Yes～</strong></span></p><p> </p>