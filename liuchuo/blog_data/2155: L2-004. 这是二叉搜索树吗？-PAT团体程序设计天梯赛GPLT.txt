<p><span style="color: #33cccc;"><strong>一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，</strong></span></p><p><span style="color: #33cccc;"><strong>其左子树中所有结点的键值小于该结点的键值；</strong></span><br><span style="color: #33cccc;"><strong>其右子树中所有结点的键值大于等于该结点的键值；</strong></span><br><span style="color: #33cccc;"><strong>其左右子树都是二叉搜索树。</strong></span><br><span style="color: #33cccc;"><strong>所谓二叉搜索树的“镜像”，即将所有结点的左右子树对换位置后所得到的树。</strong></span></p><p><span style="color: #33cccc;"><strong>给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。</strong></span></p><p><span style="color: #3366ff;"><strong>输入格式：</strong></span></p><p><span style="color: #33cccc;"><strong>输入的第一行给出正整数N（&lt;=1000）。随后一行给出N个整数键值，其间以空格分隔。</strong></span></p><p><span style="color: #3366ff;"><strong>输出格式：</strong></span></p><p><span style="color: #33cccc;"><strong>如果输入序列是对一棵二叉搜索树或其镜像进行前序遍历的结果，则首先在一行中输出“YES”，然后在下一行输出该树后序遍历的结果。数字间有1个空格，一行的首尾不得有多余空格。若答案是否，则输出“NO”。</strong></span></p><p><span style="color: #3366ff;"><strong>输入样例1：</strong></span><br><span style="color: #33cccc;"><strong>7</strong></span><br><span style="color: #33cccc;"><strong>8 6 5 7 10 8 11</strong></span><br><span style="color: #3366ff;"><strong>输出样例1：</strong></span><br><span style="color: #33cccc;"><strong>YES</strong></span><br><span style="color: #33cccc;"><strong>5 7 6 8 11 10 8</strong></span><br><span style="color: #3366ff;"><strong>输入样例2：</strong></span><br><span style="color: #33cccc;"><strong>7</strong></span><br><span style="color: #33cccc;"><strong>8 10 11 8 6 7 5</strong></span><br><span style="color: #3366ff;"><strong>输出样例2：</strong></span><br><span style="color: #33cccc;"><strong>YES</strong></span><br><span style="color: #33cccc;"><strong>11 8 10 7 5 6 8</strong></span><br><span style="color: #3366ff;"><strong>输入样例3：</strong></span><br><span style="color: #33cccc;"><strong>7</strong></span><br><span style="color: #33cccc;"><strong>8 6 8 5 10 9 11</strong></span><br><span style="color: #3366ff;"><strong>输出样例3：</strong></span><br><span style="color: #33cccc;"><strong>NO</strong></span></p><p><span style="color: #ff9900;"><strong>分析：假设它是二叉搜索树，一开始isMirror为FALSE，根据二叉搜索树的性质将已知的前序转换为后序，转换过程中，如果发现最后输出的后序数组长度不为n，那就设isMirror为true，然后清空后序数组，重新再转换一次（根据镜面二叉搜索树的性质），如果依旧转换后数组大小不等于n，就输出no否则输出yes</strong></span></p><p></p>