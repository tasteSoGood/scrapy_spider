<p><strong><span style="color: #3366ff;">101. Symmetric Tree</span></strong><br><span style="color: #33cccc;">Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</span><br><span style="color: #33cccc;"> For example, this binary tree is symmetric:</span><br><span style="color: #33cccc;"> 1</span><br><span style="color: #33cccc;"> / \\</span><br><span style="color: #33cccc;"> 2 2</span><br><span style="color: #33cccc;"> / \\ / \\</span><br><span style="color: #33cccc;"> 3 4 4 3</span><br><span style="color: #33cccc;"> But the following is not:</span><br><span style="color: #33cccc;"> 1</span><br><span style="color: #33cccc;"> / \\</span><br><span style="color: #33cccc;"> 2 2</span><br><span style="color: #33cccc;"> \\ \\</span><br><span style="color: #33cccc;"> 3 3</span><br><span style="color: #33cccc;"> Note:</span><br><span style="color: #33cccc;"> Bonus points if you could solve it both recursively and iteratively.</span><br><span style="color: #ff9900;"><strong>分析：这道题既可以用深度优先搜索，也可以用广度优先搜索。此处先用广度优先搜索来做。</strong></span><br><span style="color: #ff9900;"><strong> 建立两个队列，lq和rq，每次比较队首的两个元素是否相等。</strong></span><br><span style="color: #ff9900;"><strong> lq队列的队首l出列后，将它的left和right分别入队；</strong></span><br><span style="color: #ff9900;"><strong> rq队列的队首r出列后，将它的right和left分别入队。</strong></span><br><span style="color: #ff9900;"><strong> 因为判断是否对称是这样比较的：</strong></span><br><span style="color: #ff9900;"><strong> l-&gt;left 与 r-&gt;right</strong></span><br><span style="color: #ff9900;"><strong> l-&gt;right 与 r-&gt;left比较。</strong></span></p><p><span style="color: #3366ff;"><strong>102. Binary Tree Level Order Traversal</strong></span><br><span style="color: #33cccc;">Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</span><br><span style="color: #33cccc;"> For example:</span><br><span style="color: #33cccc;"> Given binary tree {3,9,20,#,#,15,7},</span><br><span style="color: #33cccc;"> 3</span><br><span style="color: #33cccc;"> / \\</span><br><span style="color: #33cccc;"> 9 20</span><br><span style="color: #33cccc;"> / \\</span><br><span style="color: #33cccc;"> 15 7</span><br><span style="color: #33cccc;"> return its level order traversal as:</span><br><span style="color: #33cccc;"> [</span><br><span style="color: #33cccc;"> [3],</span><br><span style="color: #33cccc;"> [9,20],</span><br><span style="color: #33cccc;"> [15,7]</span><br><span style="color: #33cccc;"> ]</span><br><strong><span style="color: #ff9900;">分析：二叉树的层序遍历，使用广度优先搜索，建立一个队列q。</span></strong><br><strong><span style="color: #ff9900;"> 每次将队首temp结点出队列的同时，将temp的左孩子和右孩子入队</span></strong><br><strong><span style="color: #ff9900;"> 用size标记入队后的队列长度</span></strong><br><strong><span style="color: #ff9900;"> row数组始终为当前层的遍历结果，然后用while(size–)语句保证每一次保存入row的只有一层。</span></strong><br><strong><span style="color: #ff9900;"> 每一次一层遍历完成后，将该row的结果存入二维数组v。</span></strong></p><p><span style="color: #3366ff;"><strong>111. Minimum Depth of Binary Tree</strong></span><br><span style="color: #33cccc;">Given a binary tree, find its minimum depth.</span><br><span style="color: #33cccc;"> The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</span><br><span style="color: #ff9900;"><strong> 分析：这道题既可以用广度优先搜索，又可以用深度优先搜索。这里用广度优先搜索解决。</strong></span><br><span style="color: #ff9900;"><strong> 建立一个存储结点的队列q。设指针p指向队首。将p出队的同时将p-&gt;left和p-&gt;right入队~</strong></span><br><span style="color: #ff9900;"><strong> 若发现p既没有left结点也没有right结点（就是说p是叶子结点）的时候直接return ans</strong></span><br><span style="color: #ff9900;"><strong> 否则在每一层遍历完成后ans++;</strong></span><br><span style="color: #ff9900;"><strong> 和上一题层序遍历相似，只是在层序遍历的过程中加入了判断是否已经是叶子结点。如果是叶子结点就直接返回当前的层数~</strong></span></p><p><span style="color: #3366ff;"><strong>279. Perfect Squares</strong></span><br><span style="color: #33cccc;">Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</span><br><span style="color: #33cccc;"> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</span><br><span style="color: #ff9900;"><strong>分析：这道题既可以用动态规划的方法来做，又可以用广度优先搜索的方法做。这里先用广度优先搜索的方法来做。</strong></span><br><span style="color: #ff9900;"><strong> 建立一个队列，并把n入队~~这个时候从后往前检索所有平方小于n的数，并把他们逐一入队；然后将temp值为队首的值，再从后往前检索所有平方小于temp的数，并把他们逐一入队。。直到有一次入队时候发现该数字为0时return。</strong></span><br><span style="color: #ff9900;"><strong> 比如设13为根节点，13 – 3 * 3 = 4， 13 – 2 * 2 = 9， 13 – 1 * 1 = 12，</strong></span><br><span style="color: #ff9900;"><strong> 4， 9， 12就是root的三个child，是第二层；</strong></span><br><span style="color: #ff9900;"><strong> 再下面一层，4 – 2 * 2 = 0， 4 – 1 * 1 = 3，4的child是0和3</strong></span><br><span style="color: #ff9900;"><strong> 因为发现了一个0，说明此时该层就为该数最少需要的平方和数字的个数~~</strong></span></p><p><span style="color: #3366ff;"><strong>199. Binary Tree Right Side View</strong></span><br><span style="color: #33cccc;">Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</span><br><span style="color: #33cccc;"> For example:</span><br><span style="color: #33cccc;"> Given the following binary tree,</span><br><span style="color: #33cccc;"> 1 &lt;—</span><br><span style="color: #33cccc;"> / \\</span><br><span style="color: #33cccc;"> 2 3 &lt;—</span><br><span style="color: #33cccc;"> \\ \\</span><br><span style="color: #33cccc;"> 5 4 &lt;—</span><br><span style="color: #33cccc;"> You should return [1, 3, 4].</span><br><strong><span style="color: #ff9900;">分析：这道题可以用广度优先搜索也可以用深度优先搜索。这里用广度优先方法解决：</span></strong><br><strong><span style="color: #ff9900;"> 如果root为空，则返回空vector。</span></strong><br><strong><span style="color: #ff9900;"> 建立存放TreeNode指针的队列，将root结点入队；</span></strong><br><strong><span style="color: #ff9900;"> 出队root的同时入队root的存在的left和right结点；</span></strong><br><strong><span style="color: #ff9900;"> 按照层序遍历的方式，把每一层的最后一个结点的值存入vector中，最后返回vector。</span></strong></p><p><strong><span style="color: #3366ff;">103. Binary Tree Zigzag Level Order Traversal</span></strong><br><span style="color: #33cccc;">Given a binary tree, return the zigzag level order traversal of its nodes values. (ie, from left to right, then right to left for the next level and alternate between).</span><br><span style="color: #33cccc;">For example:</span><br><span style="color: #33cccc;">Given binary tree {3,9,20,#,#,15,7},</span><br><span style="color: #33cccc;"> 3</span><br><span style="color: #33cccc;"> / \\</span><br><span style="color: #33cccc;"> 9 20</span><br><span style="color: #33cccc;"> / \\</span><br><span style="color: #33cccc;"> 15 7</span><br><span style="color: #33cccc;">return its zigzag level order traversal as:</span><br><span style="color: #33cccc;">[</span><br><span style="color: #33cccc;"> [3],</span><br><span style="color: #33cccc;"> [20,9],</span><br><span style="color: #33cccc;"> [15,7]</span><br><span style="color: #33cccc;">]</span><br><strong><span style="color: #ff9900;">分析：和层序遍历一样的代码，只需要加几行代码就行~~~因为要之字型存储这个二叉树~~~所以只不过在行数为双数的时候需要对当前行进行一次所有元素的倒置~可以用stack也可以用数组头尾两两交换的方法~~只需要在存入二维数组vector&lt;vector&gt; v之前倒置好row数组，再push_back到v里面就行~</span></strong></p><p>再上一道POJ上面的题目：<br><span style="color: #3366ff;"><strong>POJ 3126-Prime Path-广度优先搜索bfs</strong></span><br><span style="color: #33cccc;">The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices.</span><br><span style="color: #33cccc;"> — It is a matter of security to change such things every now and then, to keep the enemy in the dark.</span><br><span style="color: #33cccc;"> — But look, I have chosen my number 1033 for good reasons. I am the Prime minister, you know!</span><br><span style="color: #33cccc;"> — I know, so therefore your new number 8179 is also a prime. You will just have to paste four new digits over the four old ones on your office door.</span><br><span style="color: #33cccc;"> — No, it’s not that simple. Suppose that I change the first digit to an 8, then the number will read 8033 which is not a prime!</span><br><span style="color: #33cccc;"> — I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds.</span><br><span style="color: #33cccc;"> — Correct! So I must invent a scheme for going from 1033 to 8179 by a path of prime numbers where only one digit is changed from one prime to the next prime.</span></p><p><span style="color: #33cccc;">Now, the minister of finance, who had been eavesdropping, intervened.</span><br><span style="color: #33cccc;"> — No unnecessary expenditure, please! I happen to know that the price of a digit is one pound.</span><br><span style="color: #33cccc;"> — Hmm, in that case I need a computer program to minimize the cost. You do not know some very cheap software gurus, do you?</span><br><span style="color: #33cccc;"> — In fact, I do. You see, there is this programming contest going on… Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above.</span><br><span style="color: #33cccc;"> 1033</span><br><span style="color: #33cccc;"> 1733</span><br><span style="color: #33cccc;"> 3733</span><br><span style="color: #33cccc;"> 3739</span><br><span style="color: #33cccc;"> 3779</span><br><span style="color: #33cccc;"> 8779</span><br><span style="color: #33cccc;"> 8179</span><br><span style="color: #33cccc;"> The cost of this solution is 6 pounds. Note that the digit 1 which got pasted over in step 2 can not be reused in the last step – a new 1 must be purchased.</span><br><span style="color: #33cccc;"> Input</span><br><span style="color: #33cccc;"> One line with a positive number: the number of test cases (at most 100). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros).</span><br><span style="color: #33cccc;"> Output</span><br><span style="color: #33cccc;"> One line for each case, either with a number stating the minimal cost or containing the word Impossible.</span><br><span style="color: #33cccc;"> Sample Input</span><br><span style="color: #33cccc;"> 3</span><br><span style="color: #33cccc;"> 1033 8179</span><br><span style="color: #33cccc;"> 1373 8017</span><br><span style="color: #33cccc;"> 1033 1033</span><br><span style="color: #33cccc;"> Sample Output</span><br><span style="color: #33cccc;"> 6</span><br><span style="color: #33cccc;"> 7</span><br><span style="color: #33cccc;"> 0</span></p><p><span style="color: #3366ff;"><strong>POJ 3278-Catch That Cow-广度优先搜索</strong></span><br><span style="color: #33cccc;">Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</span><br><span style="color: #33cccc;"> * Walking: FJ can move from any point X to the points X – 1 or X + 1 in a single minute</span><br><span style="color: #33cccc;"> * Teleporting: FJ can move from any point X to the point 2 × X in a single minute.</span><br><span style="color: #33cccc;"> If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</span><br><span style="color: #33cccc;"> Input</span><br><span style="color: #33cccc;"> Line 1: Two space-separated integers: N and K</span><br><span style="color: #33cccc;"> Output</span><br><span style="color: #33cccc;"> Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.</span><br><span style="color: #33cccc;"> Sample Input</span><br><span style="color: #33cccc;"> 5 17</span><br><span style="color: #33cccc;"> Sample Output</span><br><span style="color: #33cccc;"> 4</span><br><span style="color: #33cccc;"> Hint</span><br><span style="color: #33cccc;"> The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes.</span></p><p>还有一道蓝桥杯上的题目：<br><strong><span style="color: #3366ff;">学霸的迷宫-算法提高</span></strong><br><span style="color: #33cccc;">问题描述</span><br><span style="color: #33cccc;"> 　　学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。</span><br><span style="color: #33cccc;"> 输入格式</span><br><span style="color: #33cccc;"> 　　第一行两个整数n， m，为迷宫的长宽。</span><br><span style="color: #33cccc;"> 　　接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1,1)的地方，即左上角，迷宫的出口在(n,m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1,1)，(n,m)可以通过。</span><br><span style="color: #33cccc;"> 输出格式</span><br><span style="color: #33cccc;"> 　　第一行一个数为需要的最少步数K。</span><br><span style="color: #33cccc;"> 　　第二行K个字符，每个字符∈{U,D,L,R},分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。</span><br><span style="color: #33cccc;"> 样例输入</span><br><span style="color: #33cccc;"> Input Sample 1:</span><br><span style="color: #33cccc;"> 3 3</span><br><span style="color: #33cccc;"> 001</span><br><span style="color: #33cccc;"> 100</span><br><span style="color: #33cccc;"> 110</span></p><p><span style="color: #33cccc;">Input Sample 2:</span><br><span style="color: #33cccc;"> 3 3</span><br><span style="color: #33cccc;"> 000</span><br><span style="color: #33cccc;"> 000</span><br><span style="color: #33cccc;"> 000</span><br><span style="color: #33cccc;"> 样例输出</span><br><span style="color: #33cccc;"> Output Sample 1:</span><br><span style="color: #33cccc;"> 4</span><br><span style="color: #33cccc;"> RDRD</span></p><p><span style="color: #33cccc;">Output Sample 2:</span><br><span style="color: #33cccc;"> 4</span><br><span style="color: #33cccc;"> DDRR</span><br><span style="color: #33cccc;"> 数据规模和约定</span><br><span style="color: #33cccc;"> 　　有20%的数据满足：1&lt;=n,m&lt;=10</span><br><span style="color: #33cccc;"> 　　有50%的数据满足：1&lt;=n,m&lt;=50</span><br><span style="color: #33cccc;"> 　　有100%的数据满足：1&lt;=n,m&lt;=500。</span></p><p></p>