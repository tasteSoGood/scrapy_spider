<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.<br>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>For example:<br>Given BST [1,null,2,2],<br>1<br>\\<br>2<br>/<br>2<br>return [2].</p><p>Note: If a tree has more than one mode, you can return them in any order.</p><p>Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p><p><span style="color: #99cc00;"><strong>题目大意：给一个二叉搜索树，求出现次数最多的数是哪个（哪些）～</strong></span></p><p><span style="color: #ff9900;"><strong>分析：二叉搜索树的中序遍历的结果恰好是所有数的递增序列，根据中序遍历结果，对于当前遍历结点，标记maxCount为最大出现次数，tempCount为当前数字出现的次数，currentVal为当前保存的值。</strong></span><br><span style="color: #ff9900;"><strong>首先，tempCount++表示当前的数字出现次数+1，如果当前结点的值不等于保存的值，就更新currentVal的值，并且将tempCount标记为1～</strong></span><br><span style="color: #ff9900;"><strong>接下来，如果tempCount即当前数字出现的次数大于maxCount，就更新maxCount，并且将result数组清零，并将当前数字放入result数组中；如果tempCount只是等于maxCount，说明是出现次数一样的，则将当前数字直接放入result数组中～</strong></span></p><p> </p>