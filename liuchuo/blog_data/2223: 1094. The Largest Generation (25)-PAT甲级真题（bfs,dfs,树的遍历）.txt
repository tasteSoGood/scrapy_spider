<p><span style="color: #33cccc;"><strong>A family hierarchy is usually presented by a pedigree tree where all the nodes on the same level belong to the same generation. Your task is to find the generation with the largest population.</strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case. Each case starts with two positive integers N (&lt;100) which is the total number of family members in the tree (and hence assume that all the members are numbered from 01 to N), and M (&lt;N) which is the number of family members who have children. Then M lines follow, each contains the information of a family member in the following format:</strong></span></p><p><span style="color: #33cccc;"><strong>ID K ID[1] ID[2] … ID[K]</strong></span></p><p><span style="color: #33cccc;"><strong>where ID is a two-digit number representing a family member, K (&gt;0) is the number of his/her children, followed by a sequence of two-digit ID’s of his/her children. For the sake of simplicity, let us fix the root ID to be 01. All the numbers in a line are separated by a space.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, print in one line the largest population number and the level of the corresponding generation. It is assumed that such a generation is unique, and the root level is defined to be 1.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>23 13</strong></span><br><span style="color: #33cccc;"><strong>21 1 23</strong></span><br><span style="color: #33cccc;"><strong>01 4 03 02 04 05</strong></span><br><span style="color: #33cccc;"><strong>03 3 06 07 08</strong></span><br><span style="color: #33cccc;"><strong>06 2 12 13</strong></span><br><span style="color: #33cccc;"><strong>13 1 21</strong></span><br><span style="color: #33cccc;"><strong>08 2 15 16</strong></span><br><span style="color: #33cccc;"><strong>02 2 09 10</strong></span><br><span style="color: #33cccc;"><strong>11 2 19 20</strong></span><br><span style="color: #33cccc;"><strong>17 1 22</strong></span><br><span style="color: #33cccc;"><strong>05 1 11</strong></span><br><span style="color: #33cccc;"><strong>07 1 14</strong></span><br><span style="color: #33cccc;"><strong>09 1 17</strong></span><br><span style="color: #33cccc;"><strong>10 1 18</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>9 4</strong></span><br><span style="color: #99cc00;"><strong>题目大意：输入树的结点个数N，结点编号为1~N，非叶子结点个数M，然后输出M个非叶子结点格子的孩子结点的编号，求结点个数最多的一层，根结点的层号为1，输出该层的结点个数以及层号&lt;(▰˘◡˘▰)&gt;</strong></span><br><span style="color: #ff9900;"><strong>分析：用DFS或者BFS，用DFS就用参数index和level标记当前遍历的结点的编号和层数，一个数组book标记当前层数level所含结点数，最后遍历一遍数组找出最大值。注意 ：book[level]++;这句话是发生在return语句判断之前的外面，即每遇到一个结点都要进行处理，而不是放在return语句的条件判断里面～～</strong></span><br><span style="color: #ff9900;"><strong>如果是BFS，就用一个数组level[i]标记i结点所处的层数，它等于它的父亲结点的level的值+1，用一个数组book，book[i]标记i层所拥有的结点数，在遍历的时候每弹出一个结点就将当前结点的层数所对应的book值+1，最后遍历一遍book数组找出最大拥有的结点数和层数～</strong></span></p><p></p><p></p><p></p><p> </p>