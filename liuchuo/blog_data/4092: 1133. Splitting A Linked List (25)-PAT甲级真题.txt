<p><strong><span style="color: #33cccc;">Given a singly linked list, you are supposed to rearrange its elements so that all the negative values appear before all of the non-negatives, and all the values in [0, K] appear before all those greater than K. The order of the elements inside each class must not be changed. For example, given the list being 18→7→-4→0→5→-6→10→11→-2 and K being 10, you must output -4→-6→-2→7→0→5→10→18→11.</span></strong></p><p><span style="color: #3366ff;"><strong>Input Specification:<br></strong></span><strong><span style="color: #33cccc;">Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (&lt;= 105) which is the total number of nodes, and a positive K (&lt;=1000). The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</span></strong></p><p><strong><span style="color: #33cccc;">Then N lines follow, each describes a node in the format:</span></strong></p><p><strong><span style="color: #33cccc;">Address Data Next</span></strong></p><p><strong><span style="color: #33cccc;">where Address is the position of the node, Data is an integer in [-105, 105], and Next is the position of the next node. It is guaranteed that the list is not empty.</span></strong></p><p><span style="color: #3366ff;"><strong>Output Specification:<br></strong></span><strong><span style="color: #33cccc;">For each case, output in order (from beginning to the end of the list) the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.</span></strong></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><strong><span style="color: #33cccc;">00100 9 10</span></strong><br><strong><span style="color: #33cccc;">23333 10 27777</span></strong><br><strong><span style="color: #33cccc;">00000 0 99999</span></strong><br><strong><span style="color: #33cccc;">00100 18 12309</span></strong><br><strong><span style="color: #33cccc;">68237 -6 23333</span></strong><br><strong><span style="color: #33cccc;">33218 -4 00000</span></strong><br><strong><span style="color: #33cccc;">48652 -2 -1</span></strong><br><strong><span style="color: #33cccc;">99999 5 68237</span></strong><br><strong><span style="color: #33cccc;">27777 11 48652</span></strong><br><strong><span style="color: #33cccc;">12309 7 33218</span></strong><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><strong><span style="color: #33cccc;">33218 -4 68237</span></strong><br><strong><span style="color: #33cccc;">68237 -6 48652</span></strong><br><strong><span style="color: #33cccc;">48652 -2 12309</span></strong><br><strong><span style="color: #33cccc;">12309 7 00000</span></strong><br><strong><span style="color: #33cccc;">00000 0 99999</span></strong><br><strong><span style="color: #33cccc;">99999 5 23333</span></strong><br><strong><span style="color: #33cccc;">23333 10 00100</span></strong><br><strong><span style="color: #33cccc;">00100 18 27777</span></strong><br><strong><span style="color: #33cccc;">27777 11 -1</span></strong></p><p><span style="color: #99cc00;"><strong>题目大意：给一个链表和K，遍历链表后将&lt;0的结点先输出，再将0～k区间的结点输出，最后输出&gt;k的结点</strong></span></p><p><strong><span style="color: #ff9900;">分析：1.所有节点用结构体｛id, data, next｝存储</span></strong><br><strong><span style="color: #ff9900;">2.遍历链表，找出在此链表中的节点，放入容器v中</span></strong><br><strong><span style="color: #ff9900;">3.把节点分三类｛（-无穷，0）, [0,k], (k,+无穷) ｝,把他们按段，按先后顺序依次放进容器ans中，最后输出即可～</span></strong></p><p></p>