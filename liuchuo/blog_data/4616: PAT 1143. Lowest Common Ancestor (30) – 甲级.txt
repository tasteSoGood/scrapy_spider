<p><span style="color: #33cccc;"><strong>The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.</strong></span><br><span style="color: #33cccc;"><strong>A binary search tree (BST) is recursively defined as a binary tree which has the following properties:</strong></span><br><span style="color: #33cccc;"><strong>The left subtree of a node contains only nodes with keys less than the node’s key.</strong></span><br><span style="color: #33cccc;"><strong>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</strong></span><br><span style="color: #33cccc;"><strong>Both the left and right subtrees must also be binary search trees.</strong></span><br><span style="color: #33cccc;"><strong>Given any two nodes in a BST, you are supposed to find their LCA.</strong></span><br><span style="color: #3366ff;"><strong>Input Specification:</strong></span><br><span style="color: #33cccc;"><strong>Each input file contains one test case. For each case, the first line gives two positive integers: M (&lt;= 1000), the number of pairs of nodes to be tested; and N (&lt;= 10000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int.</strong></span><br><span style="color: #33cccc;"><strong>Output Specification:</strong></span><br><span style="color: #33cccc;"><strong>For each given pair of U and V, print in a line “LCA of U and V is A.” if the LCA is found and A is the key. But if A is one of U and V, print “X is an ancestor of Y.” where X is A and Y is the other node. If U or V is not found in the BST, print in a line “ERROR: U is not found.” or “ERROR: V is not found.” or “ERROR: U and V are not found.”.</strong></span><br><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>6 8</strong></span><br><span style="color: #33cccc;"><strong>6 3 1 2 5 4 8 7</strong></span><br><span style="color: #33cccc;"><strong>2 5</strong></span><br><span style="color: #33cccc;"><strong>8 7</strong></span><br><span style="color: #33cccc;"><strong>1 9</strong></span><br><span style="color: #33cccc;"><strong>12 -3</strong></span><br><span style="color: #33cccc;"><strong>0 8</strong></span><br><span style="color: #33cccc;"><strong>99 99</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>LCA of 2 and 5 is 3.</strong></span><br><span style="color: #33cccc;"><strong>8 is an ancestor of 7.</strong></span><br><span style="color: #33cccc;"><strong>ERROR: 9 is not found.</strong></span><br><span style="color: #33cccc;"><strong>ERROR: 12 and -3 are not found.</strong></span><br><span style="color: #33cccc;"><strong>ERROR: 0 is not found.</strong></span><br><span style="color: #33cccc;"><strong>ERROR: 99 and 99 are not found.</strong></span></p><p><span style="color: #99cc00;"><strong>题目大意：给出一棵二叉搜索树的前序遍历，问结点u和v的共同最低祖先是谁～</strong></span><br><span style="color: #ff9900;"><strong>分析：map&lt;int, bool&gt; mp用来标记树中所有出现过的结点，遍历一遍pre数组，将当前结点标记为a，如果u和v分别在a的左、右，或者u、v其中一个就是当前a，即(a &gt;= u &amp;&amp; a &lt;= v) || (a &gt;= v &amp;&amp; a &lt;= u)，说明找到了这个共同最低祖先a，退出当前循环～最后根据要求输出结果即可～</strong></span><br><strong><span style="color: #ff99cc;">PS：30分的题目30行代码解决，1行1分，惊不惊喜？意不意外？（真的是水题啊…）</span></strong></p><p></p>