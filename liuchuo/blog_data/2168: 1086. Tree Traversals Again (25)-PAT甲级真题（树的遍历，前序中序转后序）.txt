<p><span style="color: #33cccc;"><strong>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.<br><img class="size-full wp-image-2171 aligncenter" src="http://www.liuchuo.net/wp-content/uploads/2016/08/Snip20160811_80.png" alt="Snip20160811_80" width="370" height="262" srcset="https://cdn1.liuchuo.net/wp-content/uploads/2016/08/Snip20160811_80.png 370w, https://cdn1.liuchuo.net/wp-content/uploads/2016/08/Snip20160811_80-300x212.png 300w" sizes="(max-width: 370px) 100vw, 370px"></strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</strong></span></p><p><span style="color: #33cccc;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>6</strong></span><br><span style="color: #33cccc;"><strong>Push 1</strong></span><br><span style="color: #33cccc;"><strong>Push 2</strong></span><br><span style="color: #33cccc;"><strong>Push 3</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Push 4</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Push 5</strong></span><br><span style="color: #33cccc;"><strong>Push 6</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #33cccc;"><strong>Pop</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>3 4 2 6 5 1</strong></span><br><span style="color: #99cc00;"><strong>题目大意：用栈的形式给出一棵二叉树的建立的顺序，求这棵二叉树的后序遍历</strong></span><br><span style="color: #ff9900;"><strong>分析：栈实现的是二叉树的中序遍历（左根右），而每次push入值的顺序是二叉树的前序遍历（根左右），所以该题可以用二叉树前序和中序转后序的方法做～</strong></span><br><span style="color: #ff9900;"><strong>root为当前子树的根结点在前序pre中的下标，start和end为当前子树的最左边和最右边的结点在中序in中的下标。用i找到当前子树的根结点root在中序中的下标，然后左边和右边就分别为当前根结点root的左子树和右子树。递归实现～<br><span style="color: #ff99cc;">Update：Github用户littlesevenmo给我发issue提出题目并没有说所有节点的值互不相同。因此，在有多个节点的值相同的情况下，之前的代码会输出错误的结果，所以修改后的代码中添加了key作为索引，前中后序中均保存索引值，然后用value存储具体的值，修改后的代码如下：</span><br></strong></span></p><p> </p>