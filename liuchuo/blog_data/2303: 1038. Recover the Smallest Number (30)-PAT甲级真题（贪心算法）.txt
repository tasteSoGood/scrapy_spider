<p><span style="color: #33cccc;"><strong>Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given {32, 321, 3214, 0229, 87}, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87.</strong></span></p><p><span style="color: #3366ff;"><strong>Input Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>Each input file contains one test case. Each case gives a positive integer N (&lt;=10000) followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.</strong></span></p><p><span style="color: #3366ff;"><strong>Output Specification:</strong></span></p><p><span style="color: #33cccc;"><strong>For each test case, print the smallest number in one line. Do not output leading zeros.</strong></span></p><p><span style="color: #3366ff;"><strong>Sample Input:</strong></span><br><span style="color: #33cccc;"><strong>5 32 321 3214 0229 87</strong></span><br><span style="color: #3366ff;"><strong>Sample Output:</strong></span><br><span style="color: #33cccc;"><strong>22932132143287</strong></span><br><span style="color: #99cc00;"><strong>题目大意：给一些字符串，求它们拼接起来构成最小数字的方式</strong></span><br><span style="color: #ff9900;"><strong>分析：贪心算法。让我们一起来见证cmp函数的强大之处！！～～不是按照字典序排列就可以的，必须保证两个字符串构成的数字是最小的才行，所以cmp函数写成return a + b &lt; b + a;的形式，保证它排列按照能够组成的最小数字的形式排列。</strong></span><br><span style="color: #ff9900;"><strong>因为字符串可能前面有0，这些要移除掉（用s.erase(s.begin())就可以了～嗯～string如此神奇～～）。输出拼接后的字符串即可。</strong></span><br><span style="color: #ff9900;"><strong>注意：如果移出了0之后发现s.length() == 0了，说明这个数是0，那么要特别地输出这个0，否则会什么都不输出～</strong></span></p><p> </p>